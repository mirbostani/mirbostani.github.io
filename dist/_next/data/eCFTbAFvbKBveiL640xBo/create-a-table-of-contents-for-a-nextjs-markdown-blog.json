{"pageProps":{"slug":"create-a-table-of-contents-for-a-nextjs-markdown-blog","postData":{"slug":"create-a-table-of-contents-for-a-nextjs-markdown-blog","headingAnchors":[{"heading":"h2","title":"Introduction","anchorId":"introduction"},{"heading":"h2","title":"Create a Next.js App","anchorId":"create_a_next_js_app"},{"heading":"h2","title":"Add \"Posts\" Page","anchorId":"add__posts__page"},{"heading":"h2","title":"Parse Markdown Files","anchorId":"parse_markdown_files"},{"heading":"h2","title":"Start Dev Server","anchorId":"start_dev_server"},{"heading":"h2","title":"Apply Styles","anchorId":"apply_styles"},{"heading":"h2","title":"Add Blog Page","anchorId":"add_blog_page"},{"heading":"h2","title":"View Blog Post","anchorId":"view_blog_post"},{"heading":"h2","title":"Render Markdown","anchorId":"render_markdown"},{"heading":"h2","title":"Create ToC Widget","anchorId":"create_toc_widget"},{"heading":"h2","title":"Active ToC Items","anchorId":"active_toc_items"},{"heading":"h2","title":"Conclusion","anchorId":"conclusion"}],"contentHtml":"<h2>Introduction</h2>\n<p>With all the available features offered in Next.js, you can easily create a full-fledged blog with markdown and Latex support. It enables you to write the articles in a markdown file and publish them statically. The blog pages will be generated based on the name of the markdown files, their YAML metadata, and content. Each markdown file is an article that will be rendered as an HTML page. However, to easily navigate through the page, we need a dynamic table of contents that enables us to jump to a specific heading and shows the current position in the article. In this article, we are going to build an auto-generated table of contents based on the headings of a markdown file. The output results will be as follows:</p>\n<p><img src=\"../public/post/20220524/screenshot.gif\" alt=\"Next.js Markdown Blog with ToC support\"></p>\n<p>To view the full source code, you can visit <a href=\"https://github.com/mirbostani/nextjs-markdown-blog-with-toc\">nextjs-markdown-blog-with-toc</a> or clone the repository:</p>\n<pre><code>$ git clone https://github.com/mirbostani/nextjs-markdown-blog-with-toc\n$ cd nextjs-markdown-blog-with-toc\n$ npm install\n$ npm run dev\n</code></pre>\n<h2>Create a Next.js App</h2>\n<p>The initial step is to create a Next.js project. First, make a new directory and navigate to it. Use the <code>create-next-app</code> tool to initialize a Next.js project and install dependencies.</p>\n<pre><code>$ mkdir nextjs-markdown-blog-with-toc &#x26;&#x26; cd nextjs-markdown-blog-with-toc\n$ npx create-next-app . --use-npm\n</code></pre>\n<p>If you haven't already had <code>create-next-app</code> on your system, install this CLI tool with <code>npm</code>.</p>\n<pre><code>$ npm i create-next-app\n</code></pre>\n<h2>Add \"Posts\" Page</h2>\n<p>First, we want to show a list of articles containing titles, descriptions, the author's name, and the publish date. Therefore, we need a top-level page to present this list. A suitable route would be <code>localhost:3000/posts</code>. To add it to the website, create the <code>pages/posts.js</code> file.</p>\n<p>Every <code>.js</code> file inside the <code>pages</code> directory maps to a route on your website.</p>\n<p>Inside the <code>pages/posts.js</code> file, write a function named <code>Posts</code> and export it as the default component. <code>Posts</code> receives <code>props.posts</code> as the input parameter that is an array of objects. Each object is associated with a single markdown file, i.e., a single blog post. Every post has a slug, which is the last part of the URL of the post, a title, description, author's name, and a publish date.</p>\n<p>By iterating over the <code>posts</code> array with the <code>Array.prototype.map()</code> function, we can create a list of blog posts containing the blog title and description along with its metadata. Each blog post is wrapped around a <code>&#x3C;Link></code> component. It lets you navigate to different pages inside your website. Viewers of the website should be able to browse any blog post by simply clicking on it in the list. Therefore, <code>href</code> attribute of the <code>&#x3C;Link></code> is set to <code>/posts/&#x3C;slug></code>. Additionally, due to the uniqueness of the <code>slug</code> we can use it as the value of the <code>key</code> attribute for <code>map</code>'s returned components. This <code>key</code> is mandatory for React.js to be able to determine the changes in the components of an array.</p>\n<pre><code>// pages/posts.js\n\nimport Link from \"next/link\";\n\nexport default function Posts({ posts }) {\n  return (\n    &#x3C;div className=\"posts\">\n      {posts.length > 0 &#x26;&#x26;\n        posts.map(({ slug, title, description, author, date }) => {\n          return (\n            &#x3C;Link key={slug} href={`/posts/${slug}`}>\n              &#x3C;div className=\"card\">\n                &#x3C;h1>{title}&#x3C;/h1>\n                &#x3C;p className=\"desc\">{description}&#x3C;/p>\n                &#x3C;p className=\"meta\">\n                  &#x3C;span>{`By ${author}`}&#x3C;/span>\n                  &#x3C;span>{date}&#x3C;/span>\n                &#x3C;/p>\n              &#x3C;/div>\n            &#x3C;/Link>\n          );\n        })}\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>To populate <code>props.posts</code> of the <code>Posts</code> component with the data associated with the markdown files, we can make use of <code>getStaticProps()</code> method of the <code>posts.js</code> page. On website's static built, it returns the <code>props</code> object and passes it to the default component of the page, i.e., the <code>Posts</code> function. Inside, we call a function named <code>getPosts()</code> to retrieve posts' data.</p>\n<pre><code>// pages/posts.js\n\nimport Link from \"next/link\";\nimport { getPosts } from \"../libs/posts\";\n\nexport async function getStaticProps() {\n  const posts = getPosts({ page: 1, limit: 10 });\n  return {\n    props: {\n      posts,\n    },\n  };\n}\n\nexport default function Posts({ posts }) { ... }\n</code></pre>\n<h2>Parse Markdown Files</h2>\n<p>Functions related to the data retrieval are in the <code>lib/posts.js</code> file. We define the <code>getPosts()</code> function inside it. This function reads all the markdown files inside a specified directory (<code>./posts/*.md</code>), parses the files' content to extract the metadata in YAML format, and applies a pagination mechanism.</p>\n<p>A simple example of a markdown file with front matter is as follows:</p>\n<pre><code>---\ntitle: \"How to create a Next.js App\"\ndescription: \"In this post you will learn how to create a Next.js application\"\ndate: \"2022-05-24\"\nauthor: \"mirbostani\"\n---\n\n## Introduction\n\nNext.js is an open-source web development framework.\n\n...\n</code></pre>\n<p>To parse YAML front matter, we use <a href=\"https://www.npmjs.com/package/gray-matter\">gray-matter</a> package.</p>\n<pre><code>$ npm install --save gray-matter\n</code></pre>\n<p>As the <code>*.md</code> files are placed inside the <code>posts</code> directory, we resolve the path using <code>path.resolve(\"posts\")</code>. We read the file names synchronously with <code>fs.readdirSync()</code>.</p>\n<p>The file name without the trailing <code>.md</code> string is the slug. We read the file content by <code>fs.readFileSync()</code> and parse the content with the <code>matter</code> function. We use the <code>matter(content).data</code> object to get the returned values. These properties are stored in the <code>posts</code> array. Each post object contains slug, content in markdown, metadata, and other properties.</p>\n<p>Before returning the <code>posts</code> array, we call the <code>Array.prototype.sort()</code> method to sort the data based on the <code>date</code> metadata.</p>\n<p>The last line implements pagination based on the <code>page</code> and <code>limit</code> parameters.</p>\n<pre><code>// libs/posts.js\n\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nexport function getPosts({ page, limit }) {\n  page = page ?? 1;\n  limit = limit ?? 10;\n\n  // Read the markdown files (`posts/*.md`) \n  const dirPath = path.resolve(\"posts\");\n  const fileNames = fs.readdirSync(dirPath);\n\n  // Prepare posts containing slug, content, and metadata\n  let posts = fileNames.map((fileName) => {\n    const slug = fileName.replace(/\\.md$/i, \"\");\n    const filePath = path.join(dirPath, fileName);\n    const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n    const matterObject = matter(content);\n    return {\n      slug,\n      ...matterObject.data,\n    };\n  });\n\n  // Sort posts based on `date`\n  posts\n    .sort(({ date: a }, { date: b }) => {\n      if (a > b) return 1;\n      else if (a &#x3C; b) return -1;\n      else return 0;\n    })\n    .reverse();\n\n  // Pagination\n  return posts.slice((page - 1) * limit, page * limit);\n}\n</code></pre>\n<h2>Start Dev Server</h2>\n<p>Run the <code>next dev -p 3000</code> command to start the development server. It is assigned to the NPM's <code>dev</code> script in <code>package.json</code> file.</p>\n<pre><code>$ npm run dev\n</code></pre>\n<p>Navigate to <code>localhost:3000/posts</code> in your favorite browser.</p>\n<h2>Apply Styles</h2>\n<p>Add the following CSS rules to the <code>styles/global.css</code> file:</p>\n<pre><code>/* styles/globals.css */\n\n:root {\n  --muted-color: gray;\n  --hover-color: #f7f7f7;\n}\n\n.posts {\n  margin: 2rem auto;\n  max-width: 1024px;\n  border: 1px solid var(--muted-color);\n}\n\n.card {\n  padding: 1rem 2rem;\n  cursor: pointer;\n}\n\n.card:hover {\n  background-color: var(--hover-color);\n}\n\n.card .desc {\n  margin-top: 0;\n}\n\n.card .meta {\n  display: flex;\n  flex-direction: row;\n  gap: 16px;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n</code></pre>\n<p>The class names are added to the <code>Posts</code> component's children in <code>pages/posts.js</code> using the <code>className</code> attribute. The following output will be displayed on your browser.</p>\n<p><img src=\"../public/post/20220524/posts-list.png\" alt=\"Posts list\"></p>\n<h2>Add Blog Page</h2>\n<p>Create the <code>pages/posts/[slug].js</code> file. The <code>Post</code> component receives two parameters: <code>slug</code> and <code>post</code>. They are populated by the <code>getStaticProps()</code> method. When a URL like <code>localhost:3000/posts/&#x3C;slug></code> is opened in a browser, the value of <code>&#x3C;slug></code> part of the URL will be accessible in <code>getStaticProps()</code> using <code>props.params.slug</code> variable.</p>\n<pre><code>// pages/posts/[slug].js\n\nimport { getPost, getPostsSlugs } from \"../../libs/posts\";\n\nexport async function getStaticPaths() {\n  const paths = getPostsSlugs();\n  return {\n    paths,\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const slug = params.slug;\n  const post = await getPost(slug);\n  return {\n    props: {\n      slug,\n      post,\n    },\n  };\n}\n\nexport default function Post({ slug, post }) {\n  return (\n    &#x3C;div className=\"post\">\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;p className=\"desc\">{post.description}&#x3C;/p>\n      &#x3C;div className=\"meta\">\n        &#x3C;span>{`By ${post.author}`}&#x3C;/span>\n        &#x3C;span>{post.date}&#x3C;/span>\n      &#x3C;/div>\n      &#x3C;div className=\"content\">{post.contentMarkdown}&#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Define <code>getPost()</code> and <code>getPostsSlugs()</code> methods in <code>libs/posts.js</code>. In <code>getPosts()</code>, <code>slug</code> is valid through the passed parameter. We use it to open the markdown file with the same base name, parse its content, and return it along with <code>slug</code> and other metadata.</p>\n<p>Here, <code>getPostsSlugs()</code> is responsible for providing all the available slugs. They are used in Next.js to build the static website's internal links. We iterate over all the file names, extract, and return the slugs.</p>\n<pre><code>import fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nexport function getPosts({ page, limit }) { ... }\n\nexport async function getPost(slug) {\n  const dirPath = path.resolve(\"posts\");\n  const filePath = path.join(dirPath, `${slug}.md`);\n  const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n  const matterObject = matter(content);\n  return {\n    slug,\n    contentMarkdown: matterObject.content,\n    ...matterObject.data,\n  };\n}\n\nexport function getPostsSlugs() {\n  const dirPath = path.resolve(\"posts\");\n  const fileNames = fs.readdirSync(dirPath);\n  return fileNames.map((fileName) => {\n    const slug = fileName.replace(/\\.md/, \"\");\n    return {\n      params: {\n        slug,\n      },\n    };\n  });\n}\n</code></pre>\n<h2>View Blog Post</h2>\n<p>To check if the functions are working properly, navigate to the <code>localhost:3000/posts/&#x3C;slug></code> link in which <code>&#x3C;slug></code> is the base name of a markdown file. For example, if your file is located in <code>posts/how-to-create-a-nextjs-app.md</code>, open the <code>localhost:3000/posts/how-to-create-a-nextjs-app</code> URL.</p>\n<p>In files' path, <code>posts</code> refers to a local directory; however, in URLs, <code>posts</code> refers to the directory located in <code>pages/posts</code>.</p>\n<p><img src=\"../public/post/20220524/post-raw.png\" alt=\"Raw blog post\"></p>\n<p>Now apply some styles by modifying <code>styles/global.css</code> and adding the following classes.</p>\n<pre><code>.post {\n  width: 1024px;\n  margin: 0 auto;\n}\n\n.desc {\n  margin-top: 0;\n}\n\n.meta {\n  display: flex;\n  flex-direction: row;\n  gap: 16px;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n\n.content {\n    margin: 2rem 0;\n}\n</code></pre>\n<p>If your dev server is running, you will see the changes instantaneously.</p>\n<p><img src=\"../public/post/20220524/post-styled.png\" alt=\"Styled blog post\"></p>\n<h2>Render Markdown</h2>\n<p>As you can see, the markdown content is displayed as plain text. We need some tools to convert it to a proper HTML format. Install the following packages in your project:</p>\n<pre><code>$ npm install --save react-markdown remark-math rehype-katex react-syntax-highlighter\n</code></pre>\n<p>Create a <code>Markdown</code> component in the <code>components/markdown.js</code> file. This component is a wrapper for <a href=\"https://www.npmjs.com/package/react-markdown\"><code>ReactMarkdown</code></a> component, which is responsible for converting markdown to HTML.</p>\n<p>To support rendering mathematic formulas on the website, we use the <a href=\"https://www.npmjs.com/package/remark-math\">remark-math</a> and <a href=\"https://www.npmjs.com/package/rehype-katex\">rehype-katex</a> packages.</p>\n<p><code>ReactMarkdown</code> has a <code>components</code> attribute. You can pass a function to access HTML tags and add features. To highlight the code, first, we access the <code>&#x3C;code></code> tag inside the <code>components()</code> function. We filter the ones with the <code>language-*</code> class, for example, <code>language-js</code>. Then, we wrap it with the <code>SyntaxHighlighter</code> component, passing Prism style, setting the language, enabling line numbers, passing the children, etc. However, when there is no match in the <code>language-*</code> CSS class search, we return a plain <code>&#x3C;code></code> tag accordingly.</p>\n<pre><code>// components/markdown.js\n\nimport ReactMarkdown from \"react-markdown\";\n\n// Math support\nimport remarkMath from \"remark-math\";\nimport rehypeKatex from \"rehype-katex\";\nimport \"katex/dist/katex.min.css\";\n\n// Syntax highlighting support\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { prism as LightStyle } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\n\nfunction components() {\n  return {\n    code({ node, inline, className, children, ...props }) {\n      const match = /language-(\\w+)/.exec(className || \"\");\n      return !inline &#x26;&#x26; match ? (\n        // Highlighted code\n        &#x3C;>\n          &#x3C;SyntaxHighlighter\n            style={LightStyle}\n            language={match[1]}\n            PreTag=\"div\"\n            // eslint-disable-next-line react/no-children-prop\n            children={String(children).replace(/\\n$/, \"\")}\n            showLineNumbers={true}\n            customStyle={{\n              backgroundColor: \"rgba(245, 245, 245, 1)\",\n              opacity: \"1\",\n            }}\n            codeTagProps={{\n              style: {\n                backgroundColor: \"transparent\",\n              },\n            }}\n            {...props}\n          />\n        &#x3C;/>\n      ) : (\n        // Plain code\n        &#x3C;code {...props}>\n          {children}\n        &#x3C;/code>\n      );\n    },\n  };\n}\n\n// Wrapper for ReactMarkdown\nexport default function Markdown({ children }) {\n  return (\n    &#x3C;ReactMarkdown\n      remarkPlugins={[remarkMath]}\n      rehypePlugins={[rehypeKatex]}\n      components={components()}\n    >\n      {children}\n    &#x3C;/ReactMarkdown>\n  );\n}\n</code></pre>\n<p>Now use <code>Markdown</code> by updating the <code>Post</code> component in <code>pages/posts/[slug].js</code>. Pass <code>post.contentMarkdown</code> to the <code>Markdown</code> component as a child.</p>\n<pre><code>export default function Post({ slug, post }) {\n  return (\n    &#x3C;div className=\"post\">\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;p className=\"desc\">{post.description}&#x3C;/p>\n      &#x3C;div className=\"meta\">\n        &#x3C;span>{`By ${post.author}`}&#x3C;/span>\n        &#x3C;span>{post.date}&#x3C;/span>\n      &#x3C;/div>\n      &#x3C;article className=\"content\">\n        &#x3C;Markdown>{post.contentMarkdown}&#x3C;/Markdown>\n      &#x3C;/article>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Here is an example:</p>\n<p><img src=\"../public/post/20220524/code-math-in-markdown.png\" alt=\"Code and Math in Markdown\"></p>\n<h2>Create ToC Widget</h2>\n<p>In this step, we want to create an auto-generated table of contents based on the headings available in the markdown file of the article. The following packages are required:</p>\n<pre><code>$ npm install --save remark remark-html jsdom\n</code></pre>\n<p>Modify the <code>libs/posts.js</code> file by adding the <code>getHeadingAnchors()</code> function to it. In <code>getPost()</code> method, we use <code>remark()</code> to parse the markdown content to HTML. Then, we pass it to the <code>getHeadingAnchors()</code> function, which is responsible for finding all the <code>&#x3C;h1></code>, <code>&#x3C;h2></code>, and <code>&#x3C;h3></code> tags, creating an ID based on the text content of the tag, and return the heading's type (<code>heading</code>), title (<code>title</code>), and prepared ID (<code>anchorId</code>). Finally, <code>getPost()</code> returns the heading anchors along with other properties.</p>\n<pre><code>import fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nimport { remark } from \"remark\";\nimport remarkHtml from \"remark-html\";\nimport jsdom from \"jsdom\";\n\nexport function getPosts({ page, limit }) { ... }\n\nexport async function getPost(slug) {\n  const dirPath = path.resolve(\"posts\");\n  const filePath = path.join(dirPath, `${slug}.md`);\n  const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n  const matterObject = matter(content);\n\n  // Get heading anchors\n  const processedContent = await remark()\n    .use(remarkHtml)\n    .process(matterObject.content);\n  const contentHtml = processedContent.toString();\n  const { headingAnchors, contentHtmlWithAnchors } =\n    getHeadingAnchors(contentHtml);\n\n  return {\n    slug,\n    headingAnchors, // return the anchors\n    contentMarkdown: matterObject.content,\n    ...matterObject.data,\n  };\n}\n\n// Find and return anchors based on headings\nfunction getHeadingAnchors(str) {\n  const headingAnchors = [];\n  const dom = new jsdom.JSDOM(`&#x3C;div id=\"headinganchors\">${str}&#x3C;/div>`);\n  dom.window.document.querySelectorAll(\"h1, h2, h3\").forEach((hx) => {\n    const id = hx.textContent.toLowerCase().replace(/\\s+|[^a-z0-9]/g, \"_\");\n    const anchor = dom.window.document.createElement(\"a\");\n    anchor.id = id;\n    hx.insertBefore(anchor, null);\n\n    headingAnchors.push({\n      heading: hx.nodeName.toLowerCase(),\n      title: hx.textContent,\n      anchorId: id,\n    });\n  });\n  const contentHtmlWithAnchors =\n    dom.window.document.getElementById(\"headinganchors\").innerHTML;\n  return {\n    headingAnchors,\n    contentHtmlWithAnchors,\n  };\n}\n</code></pre>\n<p>For example, applying <code>getHeadingAnchors()</code> on the following markdown content:</p>\n<pre><code># Heading 1\n\n## Heading 2\n</code></pre>\n<p>will result in:</p>\n<pre><code>[\n   {\n     heading: \"h1\",\n     title: \"Heading 1\",\n     anchorId: \"heading-1\"\n   },\n   {\n     heading: \"h2\",\n     title: \"Heading 2\",\n     anchorId: \"heading-2\"\n   },\n]\n</code></pre>\n<p>Now, on the output HTML content, we need to add anchors before headings so that when we click on a link in the table of content, the browser will jump to the respective anchor in the article.</p>\n<p>To do so, update the <code>components</code> function in <code>components/markdown.js</code> to add anchors before headings:</p>\n<pre><code>function components() {\n  const hx = (children) => {\n    const id = children\n      .join(\"\")\n      .toLowerCase()\n      .replace(/\\s+|[^a-z0-9]/gi, \"_\");\n    return (\n      &#x3C;>\n        &#x3C;a id={id} className=\"heading-anchor\">&#x3C;/a>\n        &#x3C;h3>{children}&#x3C;/h3>\n      &#x3C;/>\n    );\n  };\n  return {\n    code({ node, inline, className, children, ...props }) {\n      ...\n    },\n    h1({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n    h2({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n    h3({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n  };\n}\n</code></pre>\n<p>If you inspect the output in your browser, you should see <code>&#x3C;a></code> tags with <code>id</code> and class set to <code>heading-anchors</code> before headings.</p>\n<p><img src=\"../public/post/20220524/anchor-before-heading.png\" alt=\"Anchor Before Heading\"></p>\n<p>Modify <code>pages/posts/[slug].js</code> to add a sidebar to the blog page. The sidebar and content are the children of the wrapper <code>&#x3C;div></code>.</p>\n<pre><code>// pages/posts/[slug].js\n\nexport default function Post({ slug, post }) {\n  return (\n    &#x3C;div className=\"post\">\n      &#x3C;h1>{post.title}&#x3C;/h1>\n      &#x3C;p className=\"desc\">{post.description}&#x3C;/p>\n      &#x3C;div className=\"meta\">\n        &#x3C;span>{`By ${post.author}`}&#x3C;/span>\n        &#x3C;span>{post.date}&#x3C;/span>\n      &#x3C;/div>\n      &#x3C;div className=\"wrapper\">\n        &#x3C;aside className=\"sidebar\">\n          &#x3C;div className=\"toc\">\n            &#x3C;h1>Table of Contents&#x3C;/h1>\n            {post.headingAnchors.length > 0 &#x26;&#x26; (\n              &#x3C;ul>\n                {post.headingAnchors.map((anchor) => {\n                  return (\n                    &#x3C;li\n                      id={`toc-${anchor.anchorId}`}\n                      key={anchor.anchorId}\n                      className={`ml${anchor.heading[1]} toc-anchor`}\n                    >\n                      &#x3C;a href={`#${anchor.anchorId}`}>{anchor.title}&#x3C;/a>\n                    &#x3C;/li>\n                  );\n                })}\n              &#x3C;/ul>\n            )}\n          &#x3C;/div>\n        &#x3C;/aside>\n        &#x3C;article className=\"content\">\n          &#x3C;Markdown>{post.contentMarkdown}&#x3C;/Markdown>\n        &#x3C;/article>\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>We apply some styles to align the sidebar to the right and make it sticky when we scroll down the page. If the window's width is less than 1024px, the sidebar will be placed on top of the article. However, for windows width bigger than 1024px, the sidebar will be on the right side of the page, sticking to the top while scrolling.</p>\n<pre><code>/* styles/global.css */\n\n.ml1 {\n  margin-left: 1rem;\n}\n\n.ml2 {\n  margin-left: 2rem;\n}\n\n.ml3 {\n  margin-left: 3rem;\n}\n\n.post {\n  width: 1024px;\n  margin: 0 auto;\n}\n\n.post .desc {\n  margin-top: 0;\n}\n\n.post .meta {\n  display: flex;\n  flex-direction: row;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n\n.post .wrapper {\n  display: flex;\n  flex-direction: column;\n}\n\n.post .content {\n  margin: 2rem 0;\n}\n\n.post .sidebar {\n  display: flex;\n  flex-direction: column;\n  margin-left: var(--margin);\n}\n\n.post .toc ul {\n  padding: 0;\n}\n\n.post .toc li {\n  list-style-type: none;\n  font-weight: normal;\n}\n\n.post .toc li.active {\n  font-weight: 800 !important;\n}\n\n@media (min-width: 1024px) {\n  .post .wrapper {\n    flex-direction: row-reverse;\n  }\n\n  .post .sidebar {\n    align-self: flex-start;\n    width: 300px;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 1rem;\n  }\n\n  .post .content {\n    width: calc(100% - var(--margin) - 300px);\n  }\n}\n</code></pre>\n<h2>Active ToC Items</h2>\n<p>To make the items in the table of contents re-act and become emphasized during the scroll event, first, we have to capture the <code>scroll</code> event. To achieve this effect, we create a state named <code>scrollTop</code> with <code>useState()</code> and set its initial value to <code>0</code>. Then we capture its changes using the <code>useEffect(() => {}, [scrollTop])</code> hook inside the <code>Post</code> component.</p>\n<p>To capture the <code>scroll</code> event, we call <code>addEventListener</code> on the <code>window</code> object. Don't forget to call <code>removeEventListener</code> when <code>useEffect()</code> is finished.</p>\n<p>We call <code>updateTocAnchors()</code> on each scroll update. This method searches for the heading anchors visible on the browser's window and highlights the corresponding item on the table of contents widget based on the heading anchor ID.</p>\n<pre><code>// pages/posts/[slug].js\n\nimport { getPost, getPostsSlugs } from \"../../libs/posts\";\nimport Markdown from \"../../components/markdown\";\n\nimport { useState, useEffect } from \"react\"; // React hooks\n\nexport async function getStaticPaths() { ... }\n\nexport async function getStaticProps({ params }) { ... }\n\nexport default function Post({ slug, post }) {\n  const [scrollTop, setScrollTop] = useState(0);\n\n  useEffect(() => {\n    const updateTocAnchors = (e) => {\n      const headingAnchors = e.target.documentElement.querySelectorAll(\n        \".post .article .heading-anchor\"\n      );\n      if (headingAnchors.length === 0) return;\n      const activeHeadingAnchors = Array.from(headingAnchors).filter(\n        (anchor) => {\n          const rect = anchor.getBoundingClientRect();\n          return (\n            rect.top >= 0 &#x26;&#x26;\n            rect.left >= 0 &#x26;&#x26;\n            rect.bottom &#x3C;= e.target.documentElement.clientHeight &#x26;&#x26;\n            rect.right &#x3C;= e.target.documentElement.clientWidth\n          );\n        }\n      );\n      if (activeHeadingAnchors.length === 0) return;\n      // Deactive all ToC anchors\n      const tocAnchors = e.target.documentElement.querySelectorAll(\n        \".post .sidebar .toc .toc-anchor\"\n      );\n      if (tocAnchors.length === 0) return;\n      Array.from(tocAnchors).forEach((anchor) => {\n        anchor.classList.remove(\"active\");\n      });\n      // Active current ToC anchor\n      const tocAnchorId = `toc-${activeHeadingAnchors[0].id}`;\n      const activeTocAnchor = e.target.documentElement.querySelector(\n        `#${tocAnchorId}`\n      );\n      if (!activeTocAnchor) return;\n      activeTocAnchor.classList.add(\"active\");\n    };\n\n    // Capturing the `scroll` event\n    const onScroll = (e) => {\n      const currScrollTop = e.target.documentElement.scrollTop;\n      setScrollTop((prevScrollTop, props) => {\n        updateTocAnchors(e);\n        if (Math.abs(prevScrollTop - currScrollTop) > 200) {\n          return currScrollTop;\n        }\n      });\n    };\n    window.addEventListener(\"scroll\", onScroll);\n    return () => window.removeEventListener(\"scroll\", onScroll);\n  }, [scrollTop]);\n\n  return ( ... );\n}\n</code></pre>\n<p>After combining all the codes and logic, the results will be as follows:</p>\n<p><img src=\"../public/post/20220524/article-with-toc.png\" alt=\"Article with ToC\"></p>\n<h2>Conclusion</h2>\n<p>We are done! We have created an auto-generated table of contents, which can highlight its items based on the current scrolling position.</p>\n<p>You can find the source code on the <a href=\"https://github.com/mirbostani/nextjs-markdown-blog-with-toc\">nextjs-markdown-blog-with-toc</a> repository.</p>\n","contentHtmlWithAnchors":"<h2>Introduction<a id=\"introduction\"></a></h2>\n<p>With all the available features offered in Next.js, you can easily create a full-fledged blog with markdown and Latex support. It enables you to write the articles in a markdown file and publish them statically. The blog pages will be generated based on the name of the markdown files, their YAML metadata, and content. Each markdown file is an article that will be rendered as an HTML page. However, to easily navigate through the page, we need a dynamic table of contents that enables us to jump to a specific heading and shows the current position in the article. In this article, we are going to build an auto-generated table of contents based on the headings of a markdown file. The output results will be as follows:</p>\n<p><img src=\"../public/post/20220524/screenshot.gif\" alt=\"Next.js Markdown Blog with ToC support\"></p>\n<p>To view the full source code, you can visit <a href=\"https://github.com/mirbostani/nextjs-markdown-blog-with-toc\">nextjs-markdown-blog-with-toc</a> or clone the repository:</p>\n<pre><code>$ git clone https://github.com/mirbostani/nextjs-markdown-blog-with-toc\n$ cd nextjs-markdown-blog-with-toc\n$ npm install\n$ npm run dev\n</code></pre>\n<h2>Create a Next.js App<a id=\"create_a_next_js_app\"></a></h2>\n<p>The initial step is to create a Next.js project. First, make a new directory and navigate to it. Use the <code>create-next-app</code> tool to initialize a Next.js project and install dependencies.</p>\n<pre><code>$ mkdir nextjs-markdown-blog-with-toc &amp;&amp; cd nextjs-markdown-blog-with-toc\n$ npx create-next-app . --use-npm\n</code></pre>\n<p>If you haven't already had <code>create-next-app</code> on your system, install this CLI tool with <code>npm</code>.</p>\n<pre><code>$ npm i create-next-app\n</code></pre>\n<h2>Add \"Posts\" Page<a id=\"add__posts__page\"></a></h2>\n<p>First, we want to show a list of articles containing titles, descriptions, the author's name, and the publish date. Therefore, we need a top-level page to present this list. A suitable route would be <code>localhost:3000/posts</code>. To add it to the website, create the <code>pages/posts.js</code> file.</p>\n<p>Every <code>.js</code> file inside the <code>pages</code> directory maps to a route on your website.</p>\n<p>Inside the <code>pages/posts.js</code> file, write a function named <code>Posts</code> and export it as the default component. <code>Posts</code> receives <code>props.posts</code> as the input parameter that is an array of objects. Each object is associated with a single markdown file, i.e., a single blog post. Every post has a slug, which is the last part of the URL of the post, a title, description, author's name, and a publish date.</p>\n<p>By iterating over the <code>posts</code> array with the <code>Array.prototype.map()</code> function, we can create a list of blog posts containing the blog title and description along with its metadata. Each blog post is wrapped around a <code>&lt;Link&gt;</code> component. It lets you navigate to different pages inside your website. Viewers of the website should be able to browse any blog post by simply clicking on it in the list. Therefore, <code>href</code> attribute of the <code>&lt;Link&gt;</code> is set to <code>/posts/&lt;slug&gt;</code>. Additionally, due to the uniqueness of the <code>slug</code> we can use it as the value of the <code>key</code> attribute for <code>map</code>'s returned components. This <code>key</code> is mandatory for React.js to be able to determine the changes in the components of an array.</p>\n<pre><code>// pages/posts.js\n\nimport Link from \"next/link\";\n\nexport default function Posts({ posts }) {\n  return (\n    &lt;div className=\"posts\"&gt;\n      {posts.length &gt; 0 &amp;&amp;\n        posts.map(({ slug, title, description, author, date }) =&gt; {\n          return (\n            &lt;Link key={slug} href={`/posts/${slug}`}&gt;\n              &lt;div className=\"card\"&gt;\n                &lt;h1&gt;{title}&lt;/h1&gt;\n                &lt;p className=\"desc\"&gt;{description}&lt;/p&gt;\n                &lt;p className=\"meta\"&gt;\n                  &lt;span&gt;{`By ${author}`}&lt;/span&gt;\n                  &lt;span&gt;{date}&lt;/span&gt;\n                &lt;/p&gt;\n              &lt;/div&gt;\n            &lt;/Link&gt;\n          );\n        })}\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>To populate <code>props.posts</code> of the <code>Posts</code> component with the data associated with the markdown files, we can make use of <code>getStaticProps()</code> method of the <code>posts.js</code> page. On website's static built, it returns the <code>props</code> object and passes it to the default component of the page, i.e., the <code>Posts</code> function. Inside, we call a function named <code>getPosts()</code> to retrieve posts' data.</p>\n<pre><code>// pages/posts.js\n\nimport Link from \"next/link\";\nimport { getPosts } from \"../libs/posts\";\n\nexport async function getStaticProps() {\n  const posts = getPosts({ page: 1, limit: 10 });\n  return {\n    props: {\n      posts,\n    },\n  };\n}\n\nexport default function Posts({ posts }) { ... }\n</code></pre>\n<h2>Parse Markdown Files<a id=\"parse_markdown_files\"></a></h2>\n<p>Functions related to the data retrieval are in the <code>lib/posts.js</code> file. We define the <code>getPosts()</code> function inside it. This function reads all the markdown files inside a specified directory (<code>./posts/*.md</code>), parses the files' content to extract the metadata in YAML format, and applies a pagination mechanism.</p>\n<p>A simple example of a markdown file with front matter is as follows:</p>\n<pre><code>---\ntitle: \"How to create a Next.js App\"\ndescription: \"In this post you will learn how to create a Next.js application\"\ndate: \"2022-05-24\"\nauthor: \"mirbostani\"\n---\n\n## Introduction\n\nNext.js is an open-source web development framework.\n\n...\n</code></pre>\n<p>To parse YAML front matter, we use <a href=\"https://www.npmjs.com/package/gray-matter\">gray-matter</a> package.</p>\n<pre><code>$ npm install --save gray-matter\n</code></pre>\n<p>As the <code>*.md</code> files are placed inside the <code>posts</code> directory, we resolve the path using <code>path.resolve(\"posts\")</code>. We read the file names synchronously with <code>fs.readdirSync()</code>.</p>\n<p>The file name without the trailing <code>.md</code> string is the slug. We read the file content by <code>fs.readFileSync()</code> and parse the content with the <code>matter</code> function. We use the <code>matter(content).data</code> object to get the returned values. These properties are stored in the <code>posts</code> array. Each post object contains slug, content in markdown, metadata, and other properties.</p>\n<p>Before returning the <code>posts</code> array, we call the <code>Array.prototype.sort()</code> method to sort the data based on the <code>date</code> metadata.</p>\n<p>The last line implements pagination based on the <code>page</code> and <code>limit</code> parameters.</p>\n<pre><code>// libs/posts.js\n\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nexport function getPosts({ page, limit }) {\n  page = page ?? 1;\n  limit = limit ?? 10;\n\n  // Read the markdown files (`posts/*.md`) \n  const dirPath = path.resolve(\"posts\");\n  const fileNames = fs.readdirSync(dirPath);\n\n  // Prepare posts containing slug, content, and metadata\n  let posts = fileNames.map((fileName) =&gt; {\n    const slug = fileName.replace(/\\.md$/i, \"\");\n    const filePath = path.join(dirPath, fileName);\n    const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n    const matterObject = matter(content);\n    return {\n      slug,\n      ...matterObject.data,\n    };\n  });\n\n  // Sort posts based on `date`\n  posts\n    .sort(({ date: a }, { date: b }) =&gt; {\n      if (a &gt; b) return 1;\n      else if (a &lt; b) return -1;\n      else return 0;\n    })\n    .reverse();\n\n  // Pagination\n  return posts.slice((page - 1) * limit, page * limit);\n}\n</code></pre>\n<h2>Start Dev Server<a id=\"start_dev_server\"></a></h2>\n<p>Run the <code>next dev -p 3000</code> command to start the development server. It is assigned to the NPM's <code>dev</code> script in <code>package.json</code> file.</p>\n<pre><code>$ npm run dev\n</code></pre>\n<p>Navigate to <code>localhost:3000/posts</code> in your favorite browser.</p>\n<h2>Apply Styles<a id=\"apply_styles\"></a></h2>\n<p>Add the following CSS rules to the <code>styles/global.css</code> file:</p>\n<pre><code>/* styles/globals.css */\n\n:root {\n  --muted-color: gray;\n  --hover-color: #f7f7f7;\n}\n\n.posts {\n  margin: 2rem auto;\n  max-width: 1024px;\n  border: 1px solid var(--muted-color);\n}\n\n.card {\n  padding: 1rem 2rem;\n  cursor: pointer;\n}\n\n.card:hover {\n  background-color: var(--hover-color);\n}\n\n.card .desc {\n  margin-top: 0;\n}\n\n.card .meta {\n  display: flex;\n  flex-direction: row;\n  gap: 16px;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n</code></pre>\n<p>The class names are added to the <code>Posts</code> component's children in <code>pages/posts.js</code> using the <code>className</code> attribute. The following output will be displayed on your browser.</p>\n<p><img src=\"../public/post/20220524/posts-list.png\" alt=\"Posts list\"></p>\n<h2>Add Blog Page<a id=\"add_blog_page\"></a></h2>\n<p>Create the <code>pages/posts/[slug].js</code> file. The <code>Post</code> component receives two parameters: <code>slug</code> and <code>post</code>. They are populated by the <code>getStaticProps()</code> method. When a URL like <code>localhost:3000/posts/&lt;slug&gt;</code> is opened in a browser, the value of <code>&lt;slug&gt;</code> part of the URL will be accessible in <code>getStaticProps()</code> using <code>props.params.slug</code> variable.</p>\n<pre><code>// pages/posts/[slug].js\n\nimport { getPost, getPostsSlugs } from \"../../libs/posts\";\n\nexport async function getStaticPaths() {\n  const paths = getPostsSlugs();\n  return {\n    paths,\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const slug = params.slug;\n  const post = await getPost(slug);\n  return {\n    props: {\n      slug,\n      post,\n    },\n  };\n}\n\nexport default function Post({ slug, post }) {\n  return (\n    &lt;div className=\"post\"&gt;\n      &lt;h1&gt;{post.title}&lt;/h1&gt;\n      &lt;p className=\"desc\"&gt;{post.description}&lt;/p&gt;\n      &lt;div className=\"meta\"&gt;\n        &lt;span&gt;{`By ${post.author}`}&lt;/span&gt;\n        &lt;span&gt;{post.date}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div className=\"content\"&gt;{post.contentMarkdown}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>Define <code>getPost()</code> and <code>getPostsSlugs()</code> methods in <code>libs/posts.js</code>. In <code>getPosts()</code>, <code>slug</code> is valid through the passed parameter. We use it to open the markdown file with the same base name, parse its content, and return it along with <code>slug</code> and other metadata.</p>\n<p>Here, <code>getPostsSlugs()</code> is responsible for providing all the available slugs. They are used in Next.js to build the static website's internal links. We iterate over all the file names, extract, and return the slugs.</p>\n<pre><code>import fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nexport function getPosts({ page, limit }) { ... }\n\nexport async function getPost(slug) {\n  const dirPath = path.resolve(\"posts\");\n  const filePath = path.join(dirPath, `${slug}.md`);\n  const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n  const matterObject = matter(content);\n  return {\n    slug,\n    contentMarkdown: matterObject.content,\n    ...matterObject.data,\n  };\n}\n\nexport function getPostsSlugs() {\n  const dirPath = path.resolve(\"posts\");\n  const fileNames = fs.readdirSync(dirPath);\n  return fileNames.map((fileName) =&gt; {\n    const slug = fileName.replace(/\\.md/, \"\");\n    return {\n      params: {\n        slug,\n      },\n    };\n  });\n}\n</code></pre>\n<h2>View Blog Post<a id=\"view_blog_post\"></a></h2>\n<p>To check if the functions are working properly, navigate to the <code>localhost:3000/posts/&lt;slug&gt;</code> link in which <code>&lt;slug&gt;</code> is the base name of a markdown file. For example, if your file is located in <code>posts/how-to-create-a-nextjs-app.md</code>, open the <code>localhost:3000/posts/how-to-create-a-nextjs-app</code> URL.</p>\n<p>In files' path, <code>posts</code> refers to a local directory; however, in URLs, <code>posts</code> refers to the directory located in <code>pages/posts</code>.</p>\n<p><img src=\"../public/post/20220524/post-raw.png\" alt=\"Raw blog post\"></p>\n<p>Now apply some styles by modifying <code>styles/global.css</code> and adding the following classes.</p>\n<pre><code>.post {\n  width: 1024px;\n  margin: 0 auto;\n}\n\n.desc {\n  margin-top: 0;\n}\n\n.meta {\n  display: flex;\n  flex-direction: row;\n  gap: 16px;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n\n.content {\n    margin: 2rem 0;\n}\n</code></pre>\n<p>If your dev server is running, you will see the changes instantaneously.</p>\n<p><img src=\"../public/post/20220524/post-styled.png\" alt=\"Styled blog post\"></p>\n<h2>Render Markdown<a id=\"render_markdown\"></a></h2>\n<p>As you can see, the markdown content is displayed as plain text. We need some tools to convert it to a proper HTML format. Install the following packages in your project:</p>\n<pre><code>$ npm install --save react-markdown remark-math rehype-katex react-syntax-highlighter\n</code></pre>\n<p>Create a <code>Markdown</code> component in the <code>components/markdown.js</code> file. This component is a wrapper for <a href=\"https://www.npmjs.com/package/react-markdown\"><code>ReactMarkdown</code></a> component, which is responsible for converting markdown to HTML.</p>\n<p>To support rendering mathematic formulas on the website, we use the <a href=\"https://www.npmjs.com/package/remark-math\">remark-math</a> and <a href=\"https://www.npmjs.com/package/rehype-katex\">rehype-katex</a> packages.</p>\n<p><code>ReactMarkdown</code> has a <code>components</code> attribute. You can pass a function to access HTML tags and add features. To highlight the code, first, we access the <code>&lt;code&gt;</code> tag inside the <code>components()</code> function. We filter the ones with the <code>language-*</code> class, for example, <code>language-js</code>. Then, we wrap it with the <code>SyntaxHighlighter</code> component, passing Prism style, setting the language, enabling line numbers, passing the children, etc. However, when there is no match in the <code>language-*</code> CSS class search, we return a plain <code>&lt;code&gt;</code> tag accordingly.</p>\n<pre><code>// components/markdown.js\n\nimport ReactMarkdown from \"react-markdown\";\n\n// Math support\nimport remarkMath from \"remark-math\";\nimport rehypeKatex from \"rehype-katex\";\nimport \"katex/dist/katex.min.css\";\n\n// Syntax highlighting support\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { prism as LightStyle } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\n\nfunction components() {\n  return {\n    code({ node, inline, className, children, ...props }) {\n      const match = /language-(\\w+)/.exec(className || \"\");\n      return !inline &amp;&amp; match ? (\n        // Highlighted code\n        &lt;&gt;\n          &lt;SyntaxHighlighter\n            style={LightStyle}\n            language={match[1]}\n            PreTag=\"div\"\n            // eslint-disable-next-line react/no-children-prop\n            children={String(children).replace(/\\n$/, \"\")}\n            showLineNumbers={true}\n            customStyle={{\n              backgroundColor: \"rgba(245, 245, 245, 1)\",\n              opacity: \"1\",\n            }}\n            codeTagProps={{\n              style: {\n                backgroundColor: \"transparent\",\n              },\n            }}\n            {...props}\n          /&gt;\n        &lt;/&gt;\n      ) : (\n        // Plain code\n        &lt;code {...props}&gt;\n          {children}\n        &lt;/code&gt;\n      );\n    },\n  };\n}\n\n// Wrapper for ReactMarkdown\nexport default function Markdown({ children }) {\n  return (\n    &lt;ReactMarkdown\n      remarkPlugins={[remarkMath]}\n      rehypePlugins={[rehypeKatex]}\n      components={components()}\n    &gt;\n      {children}\n    &lt;/ReactMarkdown&gt;\n  );\n}\n</code></pre>\n<p>Now use <code>Markdown</code> by updating the <code>Post</code> component in <code>pages/posts/[slug].js</code>. Pass <code>post.contentMarkdown</code> to the <code>Markdown</code> component as a child.</p>\n<pre><code>export default function Post({ slug, post }) {\n  return (\n    &lt;div className=\"post\"&gt;\n      &lt;h1&gt;{post.title}&lt;/h1&gt;\n      &lt;p className=\"desc\"&gt;{post.description}&lt;/p&gt;\n      &lt;div className=\"meta\"&gt;\n        &lt;span&gt;{`By ${post.author}`}&lt;/span&gt;\n        &lt;span&gt;{post.date}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;article className=\"content\"&gt;\n        &lt;Markdown&gt;{post.contentMarkdown}&lt;/Markdown&gt;\n      &lt;/article&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>Here is an example:</p>\n<p><img src=\"../public/post/20220524/code-math-in-markdown.png\" alt=\"Code and Math in Markdown\"></p>\n<h2>Create ToC Widget<a id=\"create_toc_widget\"></a></h2>\n<p>In this step, we want to create an auto-generated table of contents based on the headings available in the markdown file of the article. The following packages are required:</p>\n<pre><code>$ npm install --save remark remark-html jsdom\n</code></pre>\n<p>Modify the <code>libs/posts.js</code> file by adding the <code>getHeadingAnchors()</code> function to it. In <code>getPost()</code> method, we use <code>remark()</code> to parse the markdown content to HTML. Then, we pass it to the <code>getHeadingAnchors()</code> function, which is responsible for finding all the <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, and <code>&lt;h3&gt;</code> tags, creating an ID based on the text content of the tag, and return the heading's type (<code>heading</code>), title (<code>title</code>), and prepared ID (<code>anchorId</code>). Finally, <code>getPost()</code> returns the heading anchors along with other properties.</p>\n<pre><code>import fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nimport { remark } from \"remark\";\nimport remarkHtml from \"remark-html\";\nimport jsdom from \"jsdom\";\n\nexport function getPosts({ page, limit }) { ... }\n\nexport async function getPost(slug) {\n  const dirPath = path.resolve(\"posts\");\n  const filePath = path.join(dirPath, `${slug}.md`);\n  const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n  const matterObject = matter(content);\n\n  // Get heading anchors\n  const processedContent = await remark()\n    .use(remarkHtml)\n    .process(matterObject.content);\n  const contentHtml = processedContent.toString();\n  const { headingAnchors, contentHtmlWithAnchors } =\n    getHeadingAnchors(contentHtml);\n\n  return {\n    slug,\n    headingAnchors, // return the anchors\n    contentMarkdown: matterObject.content,\n    ...matterObject.data,\n  };\n}\n\n// Find and return anchors based on headings\nfunction getHeadingAnchors(str) {\n  const headingAnchors = [];\n  const dom = new jsdom.JSDOM(`&lt;div id=\"headinganchors\"&gt;${str}&lt;/div&gt;`);\n  dom.window.document.querySelectorAll(\"h1, h2, h3\").forEach((hx) =&gt; {\n    const id = hx.textContent.toLowerCase().replace(/\\s+|[^a-z0-9]/g, \"_\");\n    const anchor = dom.window.document.createElement(\"a\");\n    anchor.id = id;\n    hx.insertBefore(anchor, null);\n\n    headingAnchors.push({\n      heading: hx.nodeName.toLowerCase(),\n      title: hx.textContent,\n      anchorId: id,\n    });\n  });\n  const contentHtmlWithAnchors =\n    dom.window.document.getElementById(\"headinganchors\").innerHTML;\n  return {\n    headingAnchors,\n    contentHtmlWithAnchors,\n  };\n}\n</code></pre>\n<p>For example, applying <code>getHeadingAnchors()</code> on the following markdown content:</p>\n<pre><code># Heading 1\n\n## Heading 2\n</code></pre>\n<p>will result in:</p>\n<pre><code>[\n   {\n     heading: \"h1\",\n     title: \"Heading 1\",\n     anchorId: \"heading-1\"\n   },\n   {\n     heading: \"h2\",\n     title: \"Heading 2\",\n     anchorId: \"heading-2\"\n   },\n]\n</code></pre>\n<p>Now, on the output HTML content, we need to add anchors before headings so that when we click on a link in the table of content, the browser will jump to the respective anchor in the article.</p>\n<p>To do so, update the <code>components</code> function in <code>components/markdown.js</code> to add anchors before headings:</p>\n<pre><code>function components() {\n  const hx = (children) =&gt; {\n    const id = children\n      .join(\"\")\n      .toLowerCase()\n      .replace(/\\s+|[^a-z0-9]/gi, \"_\");\n    return (\n      &lt;&gt;\n        &lt;a id={id} className=\"heading-anchor\"&gt;&lt;/a&gt;\n        &lt;h3&gt;{children}&lt;/h3&gt;\n      &lt;/&gt;\n    );\n  };\n  return {\n    code({ node, inline, className, children, ...props }) {\n      ...\n    },\n    h1({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n    h2({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n    h3({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n  };\n}\n</code></pre>\n<p>If you inspect the output in your browser, you should see <code>&lt;a&gt;</code> tags with <code>id</code> and class set to <code>heading-anchors</code> before headings.</p>\n<p><img src=\"../public/post/20220524/anchor-before-heading.png\" alt=\"Anchor Before Heading\"></p>\n<p>Modify <code>pages/posts/[slug].js</code> to add a sidebar to the blog page. The sidebar and content are the children of the wrapper <code>&lt;div&gt;</code>.</p>\n<pre><code>// pages/posts/[slug].js\n\nexport default function Post({ slug, post }) {\n  return (\n    &lt;div className=\"post\"&gt;\n      &lt;h1&gt;{post.title}&lt;/h1&gt;\n      &lt;p className=\"desc\"&gt;{post.description}&lt;/p&gt;\n      &lt;div className=\"meta\"&gt;\n        &lt;span&gt;{`By ${post.author}`}&lt;/span&gt;\n        &lt;span&gt;{post.date}&lt;/span&gt;\n      &lt;/div&gt;\n      &lt;div className=\"wrapper\"&gt;\n        &lt;aside className=\"sidebar\"&gt;\n          &lt;div className=\"toc\"&gt;\n            &lt;h1&gt;Table of Contents&lt;/h1&gt;\n            {post.headingAnchors.length &gt; 0 &amp;&amp; (\n              &lt;ul&gt;\n                {post.headingAnchors.map((anchor) =&gt; {\n                  return (\n                    &lt;li\n                      id={`toc-${anchor.anchorId}`}\n                      key={anchor.anchorId}\n                      className={`ml${anchor.heading[1]} toc-anchor`}\n                    &gt;\n                      &lt;a href={`#${anchor.anchorId}`}&gt;{anchor.title}&lt;/a&gt;\n                    &lt;/li&gt;\n                  );\n                })}\n              &lt;/ul&gt;\n            )}\n          &lt;/div&gt;\n        &lt;/aside&gt;\n        &lt;article className=\"content\"&gt;\n          &lt;Markdown&gt;{post.contentMarkdown}&lt;/Markdown&gt;\n        &lt;/article&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<p>We apply some styles to align the sidebar to the right and make it sticky when we scroll down the page. If the window's width is less than 1024px, the sidebar will be placed on top of the article. However, for windows width bigger than 1024px, the sidebar will be on the right side of the page, sticking to the top while scrolling.</p>\n<pre><code>/* styles/global.css */\n\n.ml1 {\n  margin-left: 1rem;\n}\n\n.ml2 {\n  margin-left: 2rem;\n}\n\n.ml3 {\n  margin-left: 3rem;\n}\n\n.post {\n  width: 1024px;\n  margin: 0 auto;\n}\n\n.post .desc {\n  margin-top: 0;\n}\n\n.post .meta {\n  display: flex;\n  flex-direction: row;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n\n.post .wrapper {\n  display: flex;\n  flex-direction: column;\n}\n\n.post .content {\n  margin: 2rem 0;\n}\n\n.post .sidebar {\n  display: flex;\n  flex-direction: column;\n  margin-left: var(--margin);\n}\n\n.post .toc ul {\n  padding: 0;\n}\n\n.post .toc li {\n  list-style-type: none;\n  font-weight: normal;\n}\n\n.post .toc li.active {\n  font-weight: 800 !important;\n}\n\n@media (min-width: 1024px) {\n  .post .wrapper {\n    flex-direction: row-reverse;\n  }\n\n  .post .sidebar {\n    align-self: flex-start;\n    width: 300px;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 1rem;\n  }\n\n  .post .content {\n    width: calc(100% - var(--margin) - 300px);\n  }\n}\n</code></pre>\n<h2>Active ToC Items<a id=\"active_toc_items\"></a></h2>\n<p>To make the items in the table of contents re-act and become emphasized during the scroll event, first, we have to capture the <code>scroll</code> event. To achieve this effect, we create a state named <code>scrollTop</code> with <code>useState()</code> and set its initial value to <code>0</code>. Then we capture its changes using the <code>useEffect(() =&gt; {}, [scrollTop])</code> hook inside the <code>Post</code> component.</p>\n<p>To capture the <code>scroll</code> event, we call <code>addEventListener</code> on the <code>window</code> object. Don't forget to call <code>removeEventListener</code> when <code>useEffect()</code> is finished.</p>\n<p>We call <code>updateTocAnchors()</code> on each scroll update. This method searches for the heading anchors visible on the browser's window and highlights the corresponding item on the table of contents widget based on the heading anchor ID.</p>\n<pre><code>// pages/posts/[slug].js\n\nimport { getPost, getPostsSlugs } from \"../../libs/posts\";\nimport Markdown from \"../../components/markdown\";\n\nimport { useState, useEffect } from \"react\"; // React hooks\n\nexport async function getStaticPaths() { ... }\n\nexport async function getStaticProps({ params }) { ... }\n\nexport default function Post({ slug, post }) {\n  const [scrollTop, setScrollTop] = useState(0);\n\n  useEffect(() =&gt; {\n    const updateTocAnchors = (e) =&gt; {\n      const headingAnchors = e.target.documentElement.querySelectorAll(\n        \".post .article .heading-anchor\"\n      );\n      if (headingAnchors.length === 0) return;\n      const activeHeadingAnchors = Array.from(headingAnchors).filter(\n        (anchor) =&gt; {\n          const rect = anchor.getBoundingClientRect();\n          return (\n            rect.top &gt;= 0 &amp;&amp;\n            rect.left &gt;= 0 &amp;&amp;\n            rect.bottom &lt;= e.target.documentElement.clientHeight &amp;&amp;\n            rect.right &lt;= e.target.documentElement.clientWidth\n          );\n        }\n      );\n      if (activeHeadingAnchors.length === 0) return;\n      // Deactive all ToC anchors\n      const tocAnchors = e.target.documentElement.querySelectorAll(\n        \".post .sidebar .toc .toc-anchor\"\n      );\n      if (tocAnchors.length === 0) return;\n      Array.from(tocAnchors).forEach((anchor) =&gt; {\n        anchor.classList.remove(\"active\");\n      });\n      // Active current ToC anchor\n      const tocAnchorId = `toc-${activeHeadingAnchors[0].id}`;\n      const activeTocAnchor = e.target.documentElement.querySelector(\n        `#${tocAnchorId}`\n      );\n      if (!activeTocAnchor) return;\n      activeTocAnchor.classList.add(\"active\");\n    };\n\n    // Capturing the `scroll` event\n    const onScroll = (e) =&gt; {\n      const currScrollTop = e.target.documentElement.scrollTop;\n      setScrollTop((prevScrollTop, props) =&gt; {\n        updateTocAnchors(e);\n        if (Math.abs(prevScrollTop - currScrollTop) &gt; 200) {\n          return currScrollTop;\n        }\n      });\n    };\n    window.addEventListener(\"scroll\", onScroll);\n    return () =&gt; window.removeEventListener(\"scroll\", onScroll);\n  }, [scrollTop]);\n\n  return ( ... );\n}\n</code></pre>\n<p>After combining all the codes and logic, the results will be as follows:</p>\n<p><img src=\"../public/post/20220524/article-with-toc.png\" alt=\"Article with ToC\"></p>\n<h2>Conclusion<a id=\"conclusion\"></a></h2>\n<p>We are done! We have created an auto-generated table of contents, which can highlight its items based on the current scrolling position.</p>\n<p>You can find the source code on the <a href=\"https://github.com/mirbostani/nextjs-markdown-blog-with-toc\">nextjs-markdown-blog-with-toc</a> repository.</p>\n","contentMarkdown":"\n## Introduction\n\nWith all the available features offered in Next.js, you can easily create a full-fledged blog with markdown and Latex support. It enables you to write the articles in a markdown file and publish them statically. The blog pages will be generated based on the name of the markdown files, their YAML metadata, and content. Each markdown file is an article that will be rendered as an HTML page. However, to easily navigate through the page, we need a dynamic table of contents that enables us to jump to a specific heading and shows the current position in the article. In this article, we are going to build an auto-generated table of contents based on the headings of a markdown file. The output results will be as follows:\n\n![Next.js Markdown Blog with ToC support](../public/post/20220524/screenshot.gif)\n\nTo view the full source code, you can visit [nextjs-markdown-blog-with-toc](https://github.com/mirbostani/nextjs-markdown-blog-with-toc) or clone the repository:\n\n```shell\n$ git clone https://github.com/mirbostani/nextjs-markdown-blog-with-toc\n$ cd nextjs-markdown-blog-with-toc\n$ npm install\n$ npm run dev\n```\n\n## Create a Next.js App\n\nThe initial step is to create a Next.js project. First, make a new directory and navigate to it. Use the `create-next-app` tool to initialize a Next.js project and install dependencies.\n\n```shell\n$ mkdir nextjs-markdown-blog-with-toc && cd nextjs-markdown-blog-with-toc\n$ npx create-next-app . --use-npm\n```\n\nIf you haven't already had `create-next-app` on your system, install this CLI tool with `npm`.\n\n```shell\n$ npm i create-next-app\n```\n\n## Add \"Posts\" Page\n\nFirst, we want to show a list of articles containing titles, descriptions, the author's name, and the publish date. Therefore, we need a top-level page to present this list. A suitable route would be `localhost:3000/posts`. To add it to the website, create the `pages/posts.js` file.\n\nEvery `.js` file inside the `pages` directory maps to a route on your website.\n\nInside the `pages/posts.js` file, write a function named `Posts` and export it as the default component. `Posts` receives `props.posts` as the input parameter that is an array of objects. Each object is associated with a single markdown file, i.e., a single blog post. Every post has a slug, which is the last part of the URL of the post, a title, description, author's name, and a publish date.\n\nBy iterating over the `posts` array with the `Array.prototype.map()` function, we can create a list of blog posts containing the blog title and description along with its metadata. Each blog post is wrapped around a `<Link>` component. It lets you navigate to different pages inside your website. Viewers of the website should be able to browse any blog post by simply clicking on it in the list. Therefore, `href` attribute of the `<Link>` is set to `/posts/<slug>`. Additionally, due to the uniqueness of the `slug` we can use it as the value of the `key` attribute for `map`'s returned components. This `key` is mandatory for React.js to be able to determine the changes in the components of an array.\n\n```js\n// pages/posts.js\n\nimport Link from \"next/link\";\n\nexport default function Posts({ posts }) {\n  return (\n    <div className=\"posts\">\n      {posts.length > 0 &&\n        posts.map(({ slug, title, description, author, date }) => {\n          return (\n            <Link key={slug} href={`/posts/${slug}`}>\n              <div className=\"card\">\n                <h1>{title}</h1>\n                <p className=\"desc\">{description}</p>\n                <p className=\"meta\">\n                  <span>{`By ${author}`}</span>\n                  <span>{date}</span>\n                </p>\n              </div>\n            </Link>\n          );\n        })}\n    </div>\n  );\n}\n```\n\nTo populate `props.posts` of the `Posts` component with the data associated with the markdown files, we can make use of `getStaticProps()` method of the `posts.js` page. On website's static built, it returns the `props` object and passes it to the default component of the page, i.e., the `Posts` function. Inside, we call a function named `getPosts()` to retrieve posts' data.\n\n```js\n// pages/posts.js\n\nimport Link from \"next/link\";\nimport { getPosts } from \"../libs/posts\";\n\nexport async function getStaticProps() {\n  const posts = getPosts({ page: 1, limit: 10 });\n  return {\n    props: {\n      posts,\n    },\n  };\n}\n\nexport default function Posts({ posts }) { ... }\n```\n\n## Parse Markdown Files\n\nFunctions related to the data retrieval are in the `lib/posts.js` file. We define the `getPosts()` function inside it. This function reads all the markdown files inside a specified directory (`./posts/*.md`), parses the files' content to extract the metadata in YAML format, and applies a pagination mechanism.\n\nA simple example of a markdown file with front matter is as follows:\n\n```md\n---\ntitle: \"How to create a Next.js App\"\ndescription: \"In this post you will learn how to create a Next.js application\"\ndate: \"2022-05-24\"\nauthor: \"mirbostani\"\n---\n\n## Introduction\n\nNext.js is an open-source web development framework.\n\n...\n```\n\nTo parse YAML front matter, we use [gray-matter](https://www.npmjs.com/package/gray-matter) package.\n\n```shell\n$ npm install --save gray-matter\n```\n\nAs the `*.md` files are placed inside the `posts` directory, we resolve the path using `path.resolve(\"posts\")`. We read the file names synchronously with `fs.readdirSync()`.\n\nThe file name without the trailing `.md` string is the slug. We read the file content by `fs.readFileSync()` and parse the content with the `matter` function. We use the `matter(content).data` object to get the returned values. These properties are stored in the `posts` array. Each post object contains slug, content in markdown, metadata, and other properties.\n\nBefore returning the `posts` array, we call the `Array.prototype.sort()` method to sort the data based on the `date` metadata.\n\nThe last line implements pagination based on the `page` and `limit` parameters.\n\n```js\n// libs/posts.js\n\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nexport function getPosts({ page, limit }) {\n  page = page ?? 1;\n  limit = limit ?? 10;\n\n  // Read the markdown files (`posts/*.md`) \n  const dirPath = path.resolve(\"posts\");\n  const fileNames = fs.readdirSync(dirPath);\n\n  // Prepare posts containing slug, content, and metadata\n  let posts = fileNames.map((fileName) => {\n    const slug = fileName.replace(/\\.md$/i, \"\");\n    const filePath = path.join(dirPath, fileName);\n    const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n    const matterObject = matter(content);\n    return {\n      slug,\n      ...matterObject.data,\n    };\n  });\n\n  // Sort posts based on `date`\n  posts\n    .sort(({ date: a }, { date: b }) => {\n      if (a > b) return 1;\n      else if (a < b) return -1;\n      else return 0;\n    })\n    .reverse();\n\n  // Pagination\n  return posts.slice((page - 1) * limit, page * limit);\n}\n```\n\n## Start Dev Server\n\nRun the `next dev -p 3000` command to start the development server. It is assigned to the NPM's `dev` script in `package.json` file.\n\n```shell\n$ npm run dev\n```\n\nNavigate to `localhost:3000/posts` in your favorite browser.\n\n## Apply Styles\n\nAdd the following CSS rules to the `styles/global.css` file:\n\n```css\n/* styles/globals.css */\n\n:root {\n  --muted-color: gray;\n  --hover-color: #f7f7f7;\n}\n\n.posts {\n  margin: 2rem auto;\n  max-width: 1024px;\n  border: 1px solid var(--muted-color);\n}\n\n.card {\n  padding: 1rem 2rem;\n  cursor: pointer;\n}\n\n.card:hover {\n  background-color: var(--hover-color);\n}\n\n.card .desc {\n  margin-top: 0;\n}\n\n.card .meta {\n  display: flex;\n  flex-direction: row;\n  gap: 16px;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n```\n\nThe class names are added to the `Posts` component's children in `pages/posts.js` using the `className` attribute. The following output will be displayed on your browser.\n\n![Posts list](../public/post/20220524/posts-list.png)\n\n## Add Blog Page\n\nCreate the `pages/posts/[slug].js` file. The `Post` component receives two parameters: `slug` and `post`. They are populated by the `getStaticProps()` method. When a URL like `localhost:3000/posts/<slug>` is opened in a browser, the value of `<slug>` part of the URL will be accessible in `getStaticProps()` using `props.params.slug` variable.\n\n```js\n// pages/posts/[slug].js\n\nimport { getPost, getPostsSlugs } from \"../../libs/posts\";\n\nexport async function getStaticPaths() {\n  const paths = getPostsSlugs();\n  return {\n    paths,\n    fallback: false,\n  };\n}\n\nexport async function getStaticProps({ params }) {\n  const slug = params.slug;\n  const post = await getPost(slug);\n  return {\n    props: {\n      slug,\n      post,\n    },\n  };\n}\n\nexport default function Post({ slug, post }) {\n  return (\n    <div className=\"post\">\n      <h1>{post.title}</h1>\n      <p className=\"desc\">{post.description}</p>\n      <div className=\"meta\">\n        <span>{`By ${post.author}`}</span>\n        <span>{post.date}</span>\n      </div>\n      <div className=\"content\">{post.contentMarkdown}</div>\n    </div>\n  );\n}\n```\n\nDefine `getPost()` and `getPostsSlugs()` methods in `libs/posts.js`. In `getPosts()`, `slug` is valid through the passed parameter. We use it to open the markdown file with the same base name, parse its content, and return it along with `slug` and other metadata.\n\nHere, `getPostsSlugs()` is responsible for providing all the available slugs. They are used in Next.js to build the static website's internal links. We iterate over all the file names, extract, and return the slugs.\n\n```js\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nexport function getPosts({ page, limit }) { ... }\n\nexport async function getPost(slug) {\n  const dirPath = path.resolve(\"posts\");\n  const filePath = path.join(dirPath, `${slug}.md`);\n  const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n  const matterObject = matter(content);\n  return {\n    slug,\n    contentMarkdown: matterObject.content,\n    ...matterObject.data,\n  };\n}\n\nexport function getPostsSlugs() {\n  const dirPath = path.resolve(\"posts\");\n  const fileNames = fs.readdirSync(dirPath);\n  return fileNames.map((fileName) => {\n    const slug = fileName.replace(/\\.md/, \"\");\n    return {\n      params: {\n        slug,\n      },\n    };\n  });\n}\n```\n\n## View Blog Post\n\nTo check if the functions are working properly, navigate to the `localhost:3000/posts/<slug>` link in which `<slug>` is the base name of a markdown file. For example, if your file is located in `posts/how-to-create-a-nextjs-app.md`, open the `localhost:3000/posts/how-to-create-a-nextjs-app` URL.\n\nIn files' path, `posts` refers to a local directory; however, in URLs, `posts` refers to the directory located in `pages/posts`.\n\n![Raw blog post](../public/post/20220524/post-raw.png)\n\nNow apply some styles by modifying `styles/global.css` and adding the following classes.\n\n```css\n.post {\n  width: 1024px;\n  margin: 0 auto;\n}\n\n.desc {\n  margin-top: 0;\n}\n\n.meta {\n  display: flex;\n  flex-direction: row;\n  gap: 16px;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n\n.content {\n    margin: 2rem 0;\n}\n```\n\nIf your dev server is running, you will see the changes instantaneously.\n\n![Styled blog post](../public/post/20220524/post-styled.png)\n\n## Render Markdown\n\nAs you can see, the markdown content is displayed as plain text. We need some tools to convert it to a proper HTML format. Install the following packages in your project:\n\n```shell\n$ npm install --save react-markdown remark-math rehype-katex react-syntax-highlighter\n```\n\nCreate a `Markdown` component in the `components/markdown.js` file. This component is a wrapper for [`ReactMarkdown`](https://www.npmjs.com/package/react-markdown) component, which is responsible for converting markdown to HTML.\n\nTo support rendering mathematic formulas on the website, we use the [remark-math](https://www.npmjs.com/package/remark-math) and [rehype-katex](https://www.npmjs.com/package/rehype-katex) packages. \n\n`ReactMarkdown` has a `components` attribute. You can pass a function to access HTML tags and add features. To highlight the code, first, we access the `<code>` tag inside the `components()` function. We filter the ones with the `language-*` class, for example, `language-js`. Then, we wrap it with the `SyntaxHighlighter` component, passing Prism style, setting the language, enabling line numbers, passing the children, etc. However, when there is no match in the `language-*` CSS class search, we return a plain `<code>` tag accordingly. \n\n```js\n// components/markdown.js\n\nimport ReactMarkdown from \"react-markdown\";\n\n// Math support\nimport remarkMath from \"remark-math\";\nimport rehypeKatex from \"rehype-katex\";\nimport \"katex/dist/katex.min.css\";\n\n// Syntax highlighting support\nimport { Prism as SyntaxHighlighter } from \"react-syntax-highlighter\";\nimport { prism as LightStyle } from \"react-syntax-highlighter/dist/cjs/styles/prism\";\n\nfunction components() {\n  return {\n    code({ node, inline, className, children, ...props }) {\n      const match = /language-(\\w+)/.exec(className || \"\");\n      return !inline && match ? (\n        // Highlighted code\n        <>\n          <SyntaxHighlighter\n            style={LightStyle}\n            language={match[1]}\n            PreTag=\"div\"\n            // eslint-disable-next-line react/no-children-prop\n            children={String(children).replace(/\\n$/, \"\")}\n            showLineNumbers={true}\n            customStyle={{\n              backgroundColor: \"rgba(245, 245, 245, 1)\",\n              opacity: \"1\",\n            }}\n            codeTagProps={{\n              style: {\n                backgroundColor: \"transparent\",\n              },\n            }}\n            {...props}\n          />\n        </>\n      ) : (\n        // Plain code\n        <code {...props}>\n          {children}\n        </code>\n      );\n    },\n  };\n}\n\n// Wrapper for ReactMarkdown\nexport default function Markdown({ children }) {\n  return (\n    <ReactMarkdown\n      remarkPlugins={[remarkMath]}\n      rehypePlugins={[rehypeKatex]}\n      components={components()}\n    >\n      {children}\n    </ReactMarkdown>\n  );\n}\n```\n\nNow use `Markdown` by updating the `Post` component in `pages/posts/[slug].js`. Pass `post.contentMarkdown` to the `Markdown` component as a child.\n\n```js\nexport default function Post({ slug, post }) {\n  return (\n    <div className=\"post\">\n      <h1>{post.title}</h1>\n      <p className=\"desc\">{post.description}</p>\n      <div className=\"meta\">\n        <span>{`By ${post.author}`}</span>\n        <span>{post.date}</span>\n      </div>\n      <article className=\"content\">\n        <Markdown>{post.contentMarkdown}</Markdown>\n      </article>\n    </div>\n  );\n}\n```\n\nHere is an example:\n\n![Code and Math in Markdown](../public/post/20220524/code-math-in-markdown.png)\n\n## Create ToC Widget\n\nIn this step, we want to create an auto-generated table of contents based on the headings available in the markdown file of the article. The following packages are required:\n\n```shell\n$ npm install --save remark remark-html jsdom\n```\n\nModify the `libs/posts.js` file by adding the `getHeadingAnchors()` function to it. In `getPost()` method, we use `remark()` to parse the markdown content to HTML. Then, we pass it to the `getHeadingAnchors()` function, which is responsible for finding all the `<h1>`, `<h2>`, and `<h3>` tags, creating an ID based on the text content of the tag, and return the heading's type (`heading`), title (`title`), and prepared ID (`anchorId`). Finally, `getPost()` returns the heading anchors along with other properties.\n\n\n```js\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport * as matter from \"gray-matter\";\n\nimport { remark } from \"remark\";\nimport remarkHtml from \"remark-html\";\nimport jsdom from \"jsdom\";\n\nexport function getPosts({ page, limit }) { ... }\n\nexport async function getPost(slug) {\n  const dirPath = path.resolve(\"posts\");\n  const filePath = path.join(dirPath, `${slug}.md`);\n  const content = fs.readFileSync(filePath, { encoding: \"utf-8\" });\n  const matterObject = matter(content);\n\n  // Get heading anchors\n  const processedContent = await remark()\n    .use(remarkHtml)\n    .process(matterObject.content);\n  const contentHtml = processedContent.toString();\n  const { headingAnchors, contentHtmlWithAnchors } =\n    getHeadingAnchors(contentHtml);\n\n  return {\n    slug,\n    headingAnchors, // return the anchors\n    contentMarkdown: matterObject.content,\n    ...matterObject.data,\n  };\n}\n\n// Find and return anchors based on headings\nfunction getHeadingAnchors(str) {\n  const headingAnchors = [];\n  const dom = new jsdom.JSDOM(`<div id=\"headinganchors\">${str}</div>`);\n  dom.window.document.querySelectorAll(\"h1, h2, h3\").forEach((hx) => {\n    const id = hx.textContent.toLowerCase().replace(/\\s+|[^a-z0-9]/g, \"_\");\n    const anchor = dom.window.document.createElement(\"a\");\n    anchor.id = id;\n    hx.insertBefore(anchor, null);\n\n    headingAnchors.push({\n      heading: hx.nodeName.toLowerCase(),\n      title: hx.textContent,\n      anchorId: id,\n    });\n  });\n  const contentHtmlWithAnchors =\n    dom.window.document.getElementById(\"headinganchors\").innerHTML;\n  return {\n    headingAnchors,\n    contentHtmlWithAnchors,\n  };\n}\n```\n\nFor example, applying `getHeadingAnchors()` on the following markdown content:\n\n```markdown\n# Heading 1\n\n## Heading 2\n```\n\nwill result in:\n\n```js\n[\n   {\n     heading: \"h1\",\n     title: \"Heading 1\",\n     anchorId: \"heading-1\"\n   },\n   {\n     heading: \"h2\",\n     title: \"Heading 2\",\n     anchorId: \"heading-2\"\n   },\n]\n```\n\nNow, on the output HTML content, we need to add anchors before headings so that when we click on a link in the table of content, the browser will jump to the respective anchor in the article.\n\nTo do so, update the `components` function in `components/markdown.js` to add anchors before headings:\n\n```js\nfunction components() {\n  const hx = (children) => {\n    const id = children\n      .join(\"\")\n      .toLowerCase()\n      .replace(/\\s+|[^a-z0-9]/gi, \"_\");\n    return (\n      <>\n        <a id={id} className=\"heading-anchor\"></a>\n        <h3>{children}</h3>\n      </>\n    );\n  };\n  return {\n    code({ node, inline, className, children, ...props }) {\n      ...\n    },\n    h1({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n    h2({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n    h3({ node, inline, className, children, ...props }) {\n      return hx(children);\n    },\n  };\n}\n```\n\nIf you inspect the output in your browser, you should see `<a>` tags with `id` and class set to `heading-anchors` before headings.\n\n![Anchor Before Heading](../public/post/20220524/anchor-before-heading.png)\n\nModify `pages/posts/[slug].js` to add a sidebar to the blog page. The sidebar and content are the children of the wrapper `<div>`.\n\n```js\n// pages/posts/[slug].js\n\nexport default function Post({ slug, post }) {\n  return (\n    <div className=\"post\">\n      <h1>{post.title}</h1>\n      <p className=\"desc\">{post.description}</p>\n      <div className=\"meta\">\n        <span>{`By ${post.author}`}</span>\n        <span>{post.date}</span>\n      </div>\n      <div className=\"wrapper\">\n        <aside className=\"sidebar\">\n          <div className=\"toc\">\n            <h1>Table of Contents</h1>\n            {post.headingAnchors.length > 0 && (\n              <ul>\n                {post.headingAnchors.map((anchor) => {\n                  return (\n                    <li\n                      id={`toc-${anchor.anchorId}`}\n                      key={anchor.anchorId}\n                      className={`ml${anchor.heading[1]} toc-anchor`}\n                    >\n                      <a href={`#${anchor.anchorId}`}>{anchor.title}</a>\n                    </li>\n                  );\n                })}\n              </ul>\n            )}\n          </div>\n        </aside>\n        <article className=\"content\">\n          <Markdown>{post.contentMarkdown}</Markdown>\n        </article>\n      </div>\n    </div>\n  );\n}\n```\n\nWe apply some styles to align the sidebar to the right and make it sticky when we scroll down the page. If the window's width is less than 1024px, the sidebar will be placed on top of the article. However, for windows width bigger than 1024px, the sidebar will be on the right side of the page, sticking to the top while scrolling.\n\n```css\n/* styles/global.css */\n\n.ml1 {\n  margin-left: 1rem;\n}\n\n.ml2 {\n  margin-left: 2rem;\n}\n\n.ml3 {\n  margin-left: 3rem;\n}\n\n.post {\n  width: 1024px;\n  margin: 0 auto;\n}\n\n.post .desc {\n  margin-top: 0;\n}\n\n.post .meta {\n  display: flex;\n  flex-direction: row;\n  color: var(--muted-color);\n  margin-top: 0;\n}\n\n.post .wrapper {\n  display: flex;\n  flex-direction: column;\n}\n\n.post .content {\n  margin: 2rem 0;\n}\n\n.post .sidebar {\n  display: flex;\n  flex-direction: column;\n  margin-left: var(--margin);\n}\n\n.post .toc ul {\n  padding: 0;\n}\n\n.post .toc li {\n  list-style-type: none;\n  font-weight: normal;\n}\n\n.post .toc li.active {\n  font-weight: 800 !important;\n}\n\n@media (min-width: 1024px) {\n  .post .wrapper {\n    flex-direction: row-reverse;\n  }\n\n  .post .sidebar {\n    align-self: flex-start;\n    width: 300px;\n    position: -webkit-sticky;\n    position: sticky;\n    top: 1rem;\n  }\n\n  .post .content {\n    width: calc(100% - var(--margin) - 300px);\n  }\n}\n```\n\n## Active ToC Items\n\nTo make the items in the table of contents re-act and become emphasized during the scroll event, first, we have to capture the `scroll` event. To achieve this effect, we create a state named `scrollTop` with `useState()` and set its initial value to `0`. Then we capture its changes using the `useEffect(() => {}, [scrollTop])` hook inside the `Post` component.\n\nTo capture the `scroll` event, we call `addEventListener` on the `window` object. Don't forget to call `removeEventListener` when `useEffect()` is finished.\n\nWe call `updateTocAnchors()` on each scroll update. This method searches for the heading anchors visible on the browser's window and highlights the corresponding item on the table of contents widget based on the heading anchor ID.\n\n```js\n// pages/posts/[slug].js\n\nimport { getPost, getPostsSlugs } from \"../../libs/posts\";\nimport Markdown from \"../../components/markdown\";\n\nimport { useState, useEffect } from \"react\"; // React hooks\n\nexport async function getStaticPaths() { ... }\n\nexport async function getStaticProps({ params }) { ... }\n\nexport default function Post({ slug, post }) {\n  const [scrollTop, setScrollTop] = useState(0);\n\n  useEffect(() => {\n    const updateTocAnchors = (e) => {\n      const headingAnchors = e.target.documentElement.querySelectorAll(\n        \".post .article .heading-anchor\"\n      );\n      if (headingAnchors.length === 0) return;\n      const activeHeadingAnchors = Array.from(headingAnchors).filter(\n        (anchor) => {\n          const rect = anchor.getBoundingClientRect();\n          return (\n            rect.top >= 0 &&\n            rect.left >= 0 &&\n            rect.bottom <= e.target.documentElement.clientHeight &&\n            rect.right <= e.target.documentElement.clientWidth\n          );\n        }\n      );\n      if (activeHeadingAnchors.length === 0) return;\n      // Deactive all ToC anchors\n      const tocAnchors = e.target.documentElement.querySelectorAll(\n        \".post .sidebar .toc .toc-anchor\"\n      );\n      if (tocAnchors.length === 0) return;\n      Array.from(tocAnchors).forEach((anchor) => {\n        anchor.classList.remove(\"active\");\n      });\n      // Active current ToC anchor\n      const tocAnchorId = `toc-${activeHeadingAnchors[0].id}`;\n      const activeTocAnchor = e.target.documentElement.querySelector(\n        `#${tocAnchorId}`\n      );\n      if (!activeTocAnchor) return;\n      activeTocAnchor.classList.add(\"active\");\n    };\n\n    // Capturing the `scroll` event\n    const onScroll = (e) => {\n      const currScrollTop = e.target.documentElement.scrollTop;\n      setScrollTop((prevScrollTop, props) => {\n        updateTocAnchors(e);\n        if (Math.abs(prevScrollTop - currScrollTop) > 200) {\n          return currScrollTop;\n        }\n      });\n    };\n    window.addEventListener(\"scroll\", onScroll);\n    return () => window.removeEventListener(\"scroll\", onScroll);\n  }, [scrollTop]);\n\n  return ( ... );\n}\n```\n\nAfter combining all the codes and logic, the results will be as follows:\n\n![Article with ToC](../public/post/20220524/article-with-toc.png)\n\n## Conclusion\n\nWe are done! We have created an auto-generated table of contents, which can highlight its items based on the current scrolling position.\n\nYou can find the source code on the [nextjs-markdown-blog-with-toc](https://github.com/mirbostani/nextjs-markdown-blog-with-toc) repository.","readTime":22,"category":"Web Development","title":"Create a Table of Contents for a Next.js Markdown Blog","description":"Build an auto-generated table of contents, which can highlight its items based on the current scrolling position","date":"2022-05-24","author":"mirbostani","cover":"","tags":"nextjs,reactjs"}},"__N_SSG":true}